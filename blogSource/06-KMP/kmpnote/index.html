<!DOCTYPE html>
<html lang="en">

<head>
  <title>
   · CTANGBLOG
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="C Tang">
<meta name="description" content="1. Guiding Question Link to heading Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
1.1 Example1 Link to heading 1 2 3 Input: haystack = &#34;sadbutsad&#34;, needle = &#34;sad&#34; Output: 0 Explanation: &#34;sad&#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. 1.2 Example2 Link to heading 1 2 3 Input: haystack = &#34;leetcode&#34;, needle = &#34;leeto&#34; Output: -1 Explanation: &#34;leeto&#34; did not occur in &#34;leetcode&#34;, so we return -1.">
<meta name="keywords" content="blog,study,personal">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="1. Guiding Question Link to heading Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
1.1 Example1 Link to heading 1 2 3 Input: haystack = &#34;sadbutsad&#34;, needle = &#34;sad&#34; Output: 0 Explanation: &#34;sad&#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. 1.2 Example2 Link to heading 1 2 3 Input: haystack = &#34;leetcode&#34;, needle = &#34;leeto&#34; Output: -1 Explanation: &#34;leeto&#34; did not occur in &#34;leetcode&#34;, so we return -1."/>

<meta property="og:title" content="" />
<meta property="og:description" content="1. Guiding Question Link to heading Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
1.1 Example1 Link to heading 1 2 3 Input: haystack = &#34;sadbutsad&#34;, needle = &#34;sad&#34; Output: 0 Explanation: &#34;sad&#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. 1.2 Example2 Link to heading 1 2 3 Input: haystack = &#34;leetcode&#34;, needle = &#34;leeto&#34; Output: -1 Explanation: &#34;leeto&#34; did not occur in &#34;leetcode&#34;, so we return -1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://CTangist.github.io/blogsource/06-kmp/kmpnote/" /><meta property="article:section" content="blogSource" />







<link rel="canonical" href="https://CTangist.github.io/blogsource/06-kmp/kmpnote/">


<link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.65236a6d834b26194eed04a2a3b45e44d9194ef9e620253705d4bef03bd7ef81.css" integrity="sha256-ZSNqbYNLJhlO7QSio7ReRNkZTvnmICU3BdS&#43;8DvX74E=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.f6534b0b446b75d9b6ad77a97d43ede2ddaeff1b6e2361fb7198d6f8fcb7f83f.css" integrity="sha256-9lNLC0Rrddm2rXepfUPt4t2u/xtuI2H7cZjW&#43;Py3&#43;D8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      CTANGBLOG
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/projects/">Projects</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/contact/">Contact me</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container page">
  <article>
    <header>
      <h1 class="title">
        <a class="title-link" href="https://CTangist.github.io/blogsource/06-kmp/kmpnote/">
          
        </a>
      </h1>
    </header>

    <h2 id="1-guiding-question">
  1. Guiding Question
  <a class="heading-link" href="#1-guiding-question">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>
<h3 id="11-example1">
  1.1 Example1
  <a class="heading-link" href="#11-example1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Input: haystack = &#34;sadbutsad&#34;, needle = &#34;sad&#34;
</span></span><span style="display:flex;"><span>Output: 0
</span></span><span style="display:flex;"><span>Explanation: &#34;sad&#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="12-example2">
  1.2 Example2
  <a class="heading-link" href="#12-example2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Input: haystack = &#34;leetcode&#34;, needle = &#34;leeto&#34;
</span></span><span style="display:flex;"><span>Output: -1
</span></span><span style="display:flex;"><span>Explanation: &#34;leeto&#34; did not occur in &#34;leetcode&#34;, so we return -1.
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="13-constraints">
  1.3 Constraints
  <a class="heading-link" href="#13-constraints">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><code>1 &lt;= haystack.length, needle.length &lt;= 1e4</code></li>
<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters</li>
</ul>
<h2 id="2-analysis">
  2. Analysis
  <a class="heading-link" href="#2-analysis">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>这是一道非常经典的<strong>字符串匹配</strong>问题——“字符串 <code>needle</code> 是否为字符串 <code>haystack</code> 的子串？如果是，<code>needle</code> 第一次出现在 <code>haystack</code> 的什么位置？”为了方便说明，我们<strong>将 <code>haystack</code> 定义为主串（S），将 <code>needle</code> 定义为模式串（P）</strong>。下图即是<a href="##GuidingQuestion" >Guiding Question</a>的例子。</p>
<p><img src="../../../static/media/06-GuidingQuestion.png" alt=""></p>
<p>字符串匹配的应用十分广泛，各个搜索引擎的关键词检索服务就是一个非常典型的例子。因此，我们需要高效的字符串匹配算法来为我们节省算力开销。这篇文章主要针对 $\text{KMP}$ 算法进行介绍，该算法全称 $Knuth$-$Morris$-$Pratt$ 字符串查找算法（由三位发明者的姓氏命名），效率很高，但是理解起来有点困难，因此作文记录一下。在介绍 $\text{KMP}$ 算法之前，我们不妨先来了解最朴素的 $Brute$-$Force$ 算法。</p>
<h3 id="21-brute-force">
  2.1 $Brute$-$Force$
  <a class="heading-link" href="#21-brute-force">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>$Brute$-$Force$ 算法以纯暴力的方式求解字符串匹配问题，它通过 <strong>按模式串（P）尺寸遍历主串（S）</strong> 的方式，穷举出所有的匹配可能，进而分析是否匹配成功。所谓匹配成功，指的是主串（S）的当前子串和模式串（P）逐字符相等，因此可以通过遍历实现：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isMatch</span>(string P, string S, <span style="color:#66d9ef">int</span> start) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> P.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>len; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (P[i] <span style="color:#f92672">!=</span> S[start<span style="color:#f92672">+</span>i]) {
</span></span><span style="display:flex;"><span>            flag <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flag;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>基于<strong>匹配成功</strong>的原则，我们可以通过 <strong>按模式串（P）尺寸遍历主串（S）</strong> 的方式实现 $Brute$-$Force$ 算法：</p>
<ul>
<li>枚举 $i_{\text{start}} = 0, 1, 2, \cdots, (\text{S.size}-\text{P.size})$；</li>
<li>将主串（S）的当前子串 $s_{i_{\text{start}}}s_{i_{\text{start}}+1}\cdots s_{i_{\text{start}}+\text{P.size}}$ 和模式串（P）进行匹配，若匹配成功，则找到了一个答案（有时需要求解模式串出现的所有位置）</li>
</ul>
<p>下面我们稍微改一下<a href="###Example1" >EXAMPLE1</a>的主串（<code>haystack (S) = &quot;sadsatsad&quot;, needle (P) = &quot;sad&quot;</code>），更好地理解 $Brute$-$Force$ 算法的运行细节：</p>
<p><img src="../../../static/media/06-bruteForce.png" alt=""></p>
<p>$Brute$-$Force$ 算法主打的就是暴力遍历，因此实现起来非常简单（这里基于 <a href="##GuidingQuestion" >Guiding Question</a> 的求解进行编码）：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bruteForce</span>(string P, string S) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> lengthP <span style="color:#f92672">=</span> P.size(), lengthS <span style="color:#f92672">=</span> S.size(), index <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;=</span>lengthS<span style="color:#f92672">-</span>lengthP; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (isMatch(P, S, i)) {
</span></span><span style="display:flex;"><span>            index <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> index;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="../../../static/media/06-result1.png" alt=""></p>
<p>虽然 $Brute$-$Force$ 算法实现可以通过 LeetCode 测试，而且运行时间惊人得很短（应该是样例的问题，这可以充分解释本题难度为 $Easy$），但在分析完它的时间复杂度后，我们会发现 $Brute$-$Force$ 算法一点儿也不“优雅”。</p>
<p>首先，定义 $\text{S.size}=|\text{S}|=n, \text{P.size}=|\text{P}|=m$。其次，根据 $Brute$-$Force$ 算法的实现逻辑，不难看出它包含两个 <code>for</code> 循环嵌套：</p>
<ul>
<li>内部的 <code>for</code> 循环用于进行主串（S）的当前子串和模式串（P）匹配，最坏的情况是需要遍历到最后一个字符才能确定匹配成功/失败，因此它的时间复杂度为 $\Omicron(m)$；</li>
<li>外部的 <code>for</code> 循环用于按模式串（P）尺寸遍历主串（S），最坏的情况是遍历到 <code>i=lengthS-lengthP</code>（联系上述代码）时才能确定答案，在该情况下，我们需要调用 <code>lengthS-lengthP+1=n-m+1</code> 次 <code>isMatch()</code> 函数；</li>
<li>由于 <code>for</code> 循环以嵌套形式执行，因此在最坏的情况下，总的时间复杂度为 $\Omicron((n-m+1)\cdot m)$，考虑到主串（S）一般比模式串（P）长很多，不妨设 $m\ll n$，则有 $\Omicron(nm)$</li>
</ul>
<h3 id="22-how-to-optimize-brute-force">
  2.2 How to Optimize $Brute$-$Force$
  <a class="heading-link" href="#22-how-to-optimize-brute-force">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>我们再来回顾一下 $Brute$-$Force$ 算法处理字符串匹配问题的最坏情况：</p>
<p><img src="../../../static/media/06-bruteForceBad.png" alt=""></p>
<p>因此，若想对 $Brute$-$Force$ 算法进行优化，我们有两个方向：</p>
<ul>
<li>内循环：<code>isMatch()</code> 函数</li>
<li>外循环：“按模式串（P）尺寸遍历主串（S）”</li>
</ul>
<p>显然，<code>isMatch()</code> 函数并没有优化的空间，因为我们只有彻底遍历两个字符串之后才能确定它们是否匹配成功（两者可能只有一个字符不同，而该字符可能出现在任何位置）。而外循环则大有可为——我们可以尝试减少调用 <code>isMatch()</code> 函数的次数。我们来看一个简单的<a href="#lizi" >#例子</a>：假设主串 <code>S = &quot;abcabcabcabc&quot;</code>，模式串 <code>P = &quot;abcabd&quot;</code>，先执行 $Brute$-$Force$ 算法：</p>
<p><img src="../../../static/media/06-KMPExample1.png" alt=""></p>
<p>从上面的例子不难看出，第 $2$ 轮匹配和第 $3$ 轮匹配是绝无可能成功的。目前已知优化 $Brute$-$Force$ 算法的途径是尽量减少调用 <code>isMatch()</code> 函数的次数，那么我们应该只关注那些有可能成功的匹配，而直接剪除不可能成功的匹配轮次。现在问题来了，<strong>我们该如何得知哪些匹配是有可能成功的呢</strong>？</p>
<p>回到上面的例子：</p>
<ol>
<li>第 $1$ 轮匹配，于 <code>S[5]</code> 匹配失败，反过来证明 <code>S[0:5]==P[0:5]</code> 成立；</li>
<li>第 $2$ 轮匹配，<code>S[1] == 'b', P[0] == 'a'</code>，绝无可能匹配成功；</li>
<li>第 $3$ 轮匹配，<code>S[2] == 'c', P[0] == 'a'</code>，绝无可能匹配成功；</li>
<li>第 $4$ 轮匹配，<code>S[3] == 'a', P[0] == 'a'</code>，有可能匹配成功，需要进一步遍历确认；</li>
</ol>
<p>然而，这样的确认需要进入下一轮匹配，调用 <code>isMatch()</code> 函数之后才能完成，无法真正地剪除不可能成功的匹配轮次。因此，我们需要仔细审视一下现在已经具备的信息。</p>
<h3 id="23-array-next">
  2.3 Array &ldquo;next&rdquo;
  <a class="heading-link" href="#23-array-next">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>模式串（P）是我们手中最为重要的信息，它是字符串匹配的目标。因此，我们可以将其视作一个在主串（S）上滑动的窗口。显然，<strong>$Brute$-$Force$ 算法窗口滑动的步长为 $1$，优化目标是通过增加滑动步长，剪除不可能成功的匹配轮次</strong>。现在，我们来看一下窗口本身能为我们带来什么信息。</p>
<p>我们利用 next 数组来存储模式串（P）本身具备的信息（<strong>next 数组的定义不唯一</strong>）：next 数组的长度和模式串相同，其中 <code>next[i]</code> 表示 <code>&quot;P[0]P[1]···P[i]&quot;</code> 子串中<strong>令前 $k$ 个字符等于后 $k$ 个字符的最大的 $k$ 值</strong>（注意，$0 \leqslant k &lt; i+1$，因为 <code>&quot;P[0]P[1]···P[i]&quot;</code> 子串总共只有 $i+1$ 个字符，而自己与自己相等对优化是没有意义的）。我们根据上面的<a href="#lizi" >例子</a>来看 next 数组是如何对应模式串（P）的：</p>
<p><img src="../../../static/media/06-nextshuzu.png" alt=""></p>
<p>事实上，这个例子并不能很好的体现出“<strong>最大的 $k$ 值</strong>”这一概念，我们可以考虑一下模式串 <code>P=&quot;aaaab&quot;</code> 的 next 数组为 <code>{0,1,2,3,0}</code>，这样可以更好地理解本文中 next 数组的定义。</p>
<p><strong>在 next 数组的帮助下，我们可以通过更改滑动窗口的步长来剪除不可能成功的匹配轮次，从而节省匹配时间</strong>：</p>
<ol>
<li>假设主串（S）的当前子串 <code>&quot;S[cur]S[cur+1]···S[cur+lengthP-1]&quot;</code> 和模式串（P）在 <code>'P[wrong]'</code> 处匹配失败，这件事本身具备一个信息：<strong><code>&quot;S[cur]S[cur+1]···S[cur+wrong-1]&quot; == &quot;P[0]P[1]···P[wrong-1]&quot;</code></strong>；</li>
<li>再来回顾模式串（P）的 next 数组，<code>next[wrong-1]</code> 表示子串 <code>&quot;P[0]P[1]···P[wrong-1]&quot;</code> 中前 <code>next[wrong-1]</code> 个字符等于后 <code>next[wrong-1]</code> 个字符，即 <code>&quot;P[0]P[1]···P[next[wrong-1]-1]&quot; == &quot;P[wrong-next[wrong-1]]P[wrong-next[wrong-1]+1]···P[wrong-1]&quot;</code>；</li>
<li>综合 1、2 得到的信息可知主串（S）当前子串 <code>&quot;S[cur]S[cur+1]···S[cur+lengthP-1]&quot;</code> 的后缀可以和模式串（P）的前缀匹配成功，即 <code>&quot;S[cur+wrong-next[wrong-1]]S[cur+wrong-next[wrong-1]+1]···S[cur+wrong-1]&quot; == &quot;P[0]P[1]···P[next[wrong-1]-1]&quot;</code>；</li>
<li>那么，我们完全可以将模式串（P）窗口向右滑动 <code>wrong-next[wrong-1]</code>，将 <code>P[0]</code> 对齐 <code>S[cur+wrong-next[wrong-1]]</code>，中间的匹配轮次被直接剪除，因为它们显然是不可能成功的。</li>
</ol>
<p>下面我们回到之前的<a href="#lizi" >例子</a>，具体理解一下 next 数组是如何对 $Brute$-$Force$ 算法进行优化的：</p>
<p><img src="../../../static/media/06-nextshuzuExample.png" alt=""></p>
<p>在这个例子中，我们应当明白如何巧妙地让窗口向右滑动，让 <code>P[0]</code> 对齐 <code>S[6]</code>。事实上很简单，我们只需要设置一个 <code>curP</code> 变量标识模式串（P）的待匹配字符，以及 <code>curS</code> 变量标识主串（S）的待匹配字符，已知例子中 <code>curS == 8, curP == 5</code> 时匹配失败，而 <code>next[curP-1] == next[4] == 2</code> 表示前 $2$ 个字符已经匹配成功了，我们<strong>只需要将 <code>P[curP]</code> 更新到第 $3$ 个字符（即 <code>curP = next[curP-1]</code>），即可完成窗口滑动</strong>，进行第 $2$ 轮匹配。</p>
<h2 id="3-kmp-code">
  3. KMP Code
  <a class="heading-link" href="#3-kmp-code">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>理解<a href="###HowtoOptimize$Brute$-$Force$" >如何优化 $Brute$-$Force$ 算法</a>和<a href="###Array%22next%22" >next数组的功能</a>之后，我们对 $\text{KMP}$ 算法已经有了完整的认识，下面只需要了解具体的算法实现。</p>
<h3 id="31-how-to-build-array-next">
  3.1 How to Build Array &ldquo;next&rdquo;
  <a class="heading-link" href="#31-how-to-build-array-next">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>我们按照 next 数组的定义，先用最朴素的算法——纯暴力进行实现：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getNextI</span>(string P, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 由于需要寻找子串&#34;P[0]P[1]···P[i]&#34;中令前 k 个字符等于后 k 个字符的最大的 k 值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这里根据 k 的取值范围 (0 &lt;= k &lt; i+1) 倒着枚举，k : i -&gt; 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i, count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(k <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;          <span style="color:#75715e">// count 用于累计相等字符个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;=</span>k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (P[j] <span style="color:#f92672">!=</span> P[i<span style="color:#f92672">-</span>k<span style="color:#f92672">+</span>j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">break</span>;      <span style="color:#75715e">// 出现不匹配字符，k 值过大
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>              count<span style="color:#f92672">++</span>;    <span style="color:#75715e">// 增加相同字符个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> k) <span style="color:#66d9ef">return</span> k;
</span></span><span style="display:flex;"><span>      k<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> getNext(string P) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> lengthP <span style="color:#f92672">=</span> P.size(), k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 遍历模式串P，依次计算next[i]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>lengthP; <span style="color:#f92672">++</span>i) next.push_back(getNextI(P, i));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> next;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然，上述算法的时间复杂度是很高的——$\Omicron(m^3)$。那么该如何用更高效的算法得到 next 数组呢？个人认为对计算 next 数组的优化是 $\text{KMP}$ 算法最精妙之处：</p>
<p>$\text{KMP}$ 之所以高效，是建立在充分利用已有知识的基础上。而暴力算法在计算 next 数组时，不难看出 <code>next[i]</code> 的计算是独立的，它没有利用已经具备的 <code>next[0],next[1],···,next[i-1]</code> 信息，因此不够快！那么，这些已经求得的 next 数组值具备什么样的信息呢？我们先来看 <strong><code>next[i-1]</code>，它表示模式串（P） <code>&quot;P[0]P[1]···P[i-1]&quot;</code> 子串的前 <code>next[i-1]</code> 个字符等于后 <code>next[i-1]</code> 个字符</strong>，现在回到 <code>next[i]</code> 的值，我们需要考虑 $2$ 种情况：</p>
<ol>
<li>
<p><code>P[next[i-1]] == P[i]</code>：此时只需要在 <code>next[i-1]</code> 的基础上往后扩展一位，即 <code>next[i] = next[i-1] + 1</code>；
<img src="../../../static/media/06-nextPro1.png" alt=""></p>
</li>
<li>
<p><code>P[next[i-1]] != P[i]</code>：这种情况远比第一种复杂，但我们仍然可以利用 <code>next[0],next[1],···,next[i-1]</code> 信息来求解。这里我们来看一个更加复杂的新例子：
<img src="../../../static/media/06-nextPro2.png" alt="">
现在需要求解 <code>next[11]</code>。已知 <code>next[10] == 5</code>，表示子串 <code>&quot;P[0]P[1]···P[10]&quot;</code> 中前 $5$ 个字符等于后 $5$ 个字符（已在图中标出）。此时，我们遗憾地发现 <code>next[5] != next[11]</code>，因而无法基于 <code>next[10]</code> 向后扩展。但是，“<strong>前 $5$ 个字符等于后 $5$ 个字符</strong>” 包括更加丰富的信息：定义“前 $5$ 个字符”为<code>front5</code>，“后 $5$ 个字符”为<code>back5</code>，若此时 <code>front5</code> 的某个前缀等于后缀，那么由 <code>front5 == back5</code> 可得 <code>front5</code> 的该前缀等于 <code>back5</code> 相同尺寸的后缀。这个思想就是所谓的——<strong>回溯</strong>！
<img src="../../../static/media/06-nextPro3.png" alt="">
回溯的方法也很简单——利用之前求得的 next 数组值即可：<code>next[next[10]-1] == next[5-1] == next[4] == 2</code>。此时，我们惊喜地发现 <code>P[2] == P[11]</code> 符合第一种情况，直接基于 <code>next[4]</code> 向后扩展一位即可——<code>next[11] = next[4]+1 == 2+1</code>。当然，如果此时仍然属于第二种情况，我们只需要继续回溯即可。</p>
</li>
</ol>
<p>凝练一下上述思路，完成编码：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> getNextPro(string P) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> lengthP <span style="color:#f92672">=</span> P.size(), curK <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> next;
</span></span><span style="display:flex;"><span>  next.push_back(<span style="color:#ae81ff">0</span>);              <span style="color:#75715e">// next[0] == 0 显然成立
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> lengthP) {           <span style="color:#75715e">// 从 next[1] 开始计算，方便回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (P[i] <span style="color:#f92672">==</span> P[curK]) {      <span style="color:#75715e">// 符合第一种情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          curK<span style="color:#f92672">++</span>;                 <span style="color:#75715e">// 基于 next[i-1] 往后扩展一位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          next.push_back(curK);
</span></span><span style="display:flex;"><span>          i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (curK <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {         <span style="color:#75715e">// 仍有回溯的空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>              curK <span style="color:#f92672">=</span> next[curK<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>          } <span style="color:#66d9ef">else</span> {                <span style="color:#75715e">// curK 等于 0，不会再出现匹配成功的可能
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>              next.push_back(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>              i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> next;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="32-match-with-array-next">
  3.2 Match with Array &ldquo;next&rdquo;
  <a class="heading-link" href="#32-match-with-array-next">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>得到 next 数组之后，我们就可以在它的帮助下完成 $\text{KMP}$ 算法的字符串匹配——<strong>利用 next 数组值调整窗口滑动步长</strong>：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">KMP</span>(string P, string S) {
</span></span><span style="display:flex;"><span>  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> next <span style="color:#f92672">=</span> getNextPro(P);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  curS:    存储主串（S）当前待匹配字符的索引；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  curP:    存储模式串（P）当前待匹配字符的索引；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  lengthS: 存储主串（S）的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  lengthP: 存储模式串（P）的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> curS <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, curP <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, lengthS <span style="color:#f92672">=</span> S.size(), lengthP <span style="color:#f92672">=</span> P.size();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (curS <span style="color:#f92672">&lt;</span> lengthS) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (P[curP] <span style="color:#f92672">==</span> S[curS]) {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 当前字符匹配成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          curP<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>          curS<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {    <span style="color:#75715e">// 匹配失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#75715e">// 若第一个字符就不匹配，则将窗口向右滑动一位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> (curP <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) curS<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 否则利用next[curP-1]设置窗口滑动步长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">else</span> curP <span style="color:#f92672">=</span> next[curP<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果一直到模式串最后都匹配成功，则返回S当前子串的起始位置索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (curP <span style="color:#f92672">==</span> lengthP) <span style="color:#66d9ef">return</span> curS<span style="color:#f92672">-</span>lengthP;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>不难看出 $\text{KMP}$ 算法的时间复杂度仅有 $\Omicron(n+m)$，效率提升很大（尽管在 LeetCode 的测试结果中看不出来）。</p>
<p><img src="../../../static/media/06-result2.png" alt=""></p>
<h2 id="references">
  REFERENCES
  <a class="heading-link" href="#references">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>[1] <a href="https://www.zhihu.com/question/21923021/answer/1032665486"  class="external-link" target="_blank" rel="noopener">如何更好地理解和掌握 KMP 算法?</a></p>

  </article>
</section>

  

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2022 -
    
    2023
     C Tang 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>